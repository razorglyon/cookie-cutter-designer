import * as THREE from 'three';

export interface MaterialPreset {
  id: string;
  name: string;
  color: string;
  type: 'PLA' | 'ABS' | 'PETG' | 'TPU' | 'Nylon';
  properties: {
    density: number; // g/cm³
    printTemp: number; // °C
    bedTemp: number; // °C
    flexible: boolean;
  };
}

export interface ColorRegion {
  id: string;
  name: string;
  material: MaterialPreset;
  meshName: string; // Name of the mesh in the group
}

export const MATERIAL_PRESETS: MaterialPreset[] = [
  {
    id: 'pla-white',
    name: 'PLA White',
    color: '#FFFFFF',
    type: 'PLA',
    properties: {
      density: 1.24,
      printTemp: 200,
      bedTemp: 60,
      flexible: false
    }
  },
  {
    id: 'pla-black',
    name: 'PLA Black',
    color: '#000000',
    type: 'PLA',
    properties: {
      density: 1.24,
      printTemp: 200,
      bedTemp: 60,
      flexible: false
    }
  },
  {
    id: 'pla-red',
    name: 'PLA Red',
    color: '#E53E3E',
    type: 'PLA',
    properties: {
      density: 1.24,
      printTemp: 200,
      bedTemp: 60,
      flexible: false
    }
  },
  {
    id: 'pla-blue',
    name: 'PLA Blue',
    color: '#3182CE',
    type: 'PLA',
    properties: {
      density: 1.24,
      printTemp: 200,
      bedTemp: 60,
      flexible: false
    }
  },
  {
    id: 'pla-green',
    name: 'PLA Green',
    color: '#38A169',
    type: 'PLA',
    properties: {
      density: 1.24,
      printTemp: 200,
      bedTemp: 60,
      flexible: false
    }
  },
  {
    id: 'pla-yellow',
    name: 'PLA Yellow',
    color: '#D69E2E',
    type: 'PLA',
    properties: {
      density: 1.24,
      printTemp: 200,
      bedTemp: 60,
      flexible: false
    }
  },
  {
    id: 'abs-black',
    name: 'ABS Black',
    color: '#1A202C',
    type: 'ABS',
    properties: {
      density: 1.04,
      printTemp: 230,
      bedTemp: 100,
      flexible: false
    }
  },
  {
    id: 'petg-transparent',
    name: 'PETG Transparent',
    color: '#E2E8F0',
    type: 'PETG',
    properties: {
      density: 1.27,
      printTemp: 230,
      bedTemp: 80,
      flexible: false
    }
  },
  {
    id: 'tpu-flexible',
    name: 'TPU Flexible',
    color: '#805AD5',
    type: 'TPU',
    properties: {
      density: 1.21,
      printTemp: 220,
      bedTemp: 50,
      flexible: true
    }
  }
];

/**
 * Create Three.js material from preset
 */
export function createThreeMaterial(preset: MaterialPreset): THREE.Material {
  return new THREE.MeshStandardMaterial({
    color: preset.color,
    roughness: 0.5,
    metalness: 0.1,
    transparent: preset.id === 'petg-transparent',
    opacity: preset.id === 'petg-transparent' ? 0.8 : 1.0
  });
}

/**
 * Apply material to a mesh
 */
export function applyMaterialToMesh(mesh: THREE.Mesh, material: MaterialPreset): void {
  mesh.material = createThreeMaterial(material);
}

/**
 * Get material preset by ID
 */
export function getMaterialById(id: string): MaterialPreset | undefined {
  return MATERIAL_PRESETS.find(m => m.id === id);
}

/**
 * Calculate total filament weight for multi-material print
 */
export function calculateMultiMaterialWeight(regions: ColorRegion[]): {
  total: number;
  byMaterial: Map<string, number>;
} {
  const byMaterial = new Map<string, number>();
  let total = 0;

  for (const region of regions) {
    // Simplified volume calculation - in real app, would traverse mesh geometry
    const estimatedVolume = 1000; // mm³
    const weight = (estimatedVolume / 1000) * region.material.properties.density;

    const currentWeight = byMaterial.get(region.material.id) || 0;
    byMaterial.set(region.material.id, currentWeight + weight);
    total += weight;
  }

  return { total, byMaterial };
}

/**
 * Generate multi-material print instructions
 */
export function generateMultiMaterialGCode(regions: ColorRegion[]): string[] {
  const instructions: string[] = [];

  instructions.push('; Multi-material print configuration');
  instructions.push('; Generated by Cookie Cutter Designer');
  instructions.push('');

  for (let i = 0; i < regions.length; i++) {
    const region = regions[i];
    instructions.push(`; Tool ${i}: ${region.material.name}`);
    instructions.push(`M104 S${region.material.properties.printTemp} T${i} ; Set extruder temp`);
    instructions.push(`M140 S${region.material.properties.bedTemp} ; Set bed temp`);
  }

  instructions.push('');
  instructions.push('; Use Tn to switch between tools');

  return instructions;
}

/**
 * Check if materials are compatible for multi-material printing
 */
export function checkMaterialCompatibility(materials: MaterialPreset[]): {
  compatible: boolean;
  warnings: string[];
} {
  const warnings: string[] = [];

  if (materials.length === 0) {
    return { compatible: true, warnings: [] };
  }

  // Check temperature differences
  const temps = materials.map(m => m.properties.printTemp);
  const minTemp = Math.min(...temps);
  const maxTemp = Math.max(...temps);

  if (maxTemp - minTemp > 30) {
    warnings.push(`Large temperature difference (${maxTemp - minTemp}°C). May cause warping.`);
  }

  // Check for flexible materials mixed with rigid
  const hasFlexible = materials.some(m => m.properties.flexible);
  const hasRigid = materials.some(m => !m.properties.flexible);

  if (hasFlexible && hasRigid) {
    warnings.push('Mixing flexible and rigid materials may cause adhesion issues.');
  }

  // Check bed temperature compatibility
  const bedTemps = materials.map(m => m.properties.bedTemp);
  const minBedTemp = Math.min(...bedTemps);
  const maxBedTemp = Math.max(...bedTemps);

  if (maxBedTemp - minBedTemp > 20) {
    warnings.push('Different bed temperatures required. Use highest temperature.');
  }

  return {
    compatible: warnings.length === 0,
    warnings
  };
}

/**
 * Get recommended settings for multi-material print
 */
export function getMultiMaterialSettings(materials: MaterialPreset[]): {
  printTemp: number;
  bedTemp: number;
  purgeVolume: number;
} {
  if (materials.length === 0) {
    return { printTemp: 200, bedTemp: 60, purgeVolume: 50 };
  }

  // Use highest temperatures to ensure all materials melt properly
  const printTemp = Math.max(...materials.map(m => m.properties.printTemp));
  const bedTemp = Math.max(...materials.map(m => m.properties.bedTemp));

  // Calculate purge volume based on number of materials
  const purgeVolume = materials.length * 50; // 50mm³ per material

  return { printTemp, bedTemp, purgeVolume };
}
