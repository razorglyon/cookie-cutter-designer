import * as THREE from 'three';
import { OBJExporter } from 'three/examples/jsm/exporters/OBJExporter.js';
import type { Mesh, Group } from 'three';
import type { CookieCutterParams } from '../types/CookieCutter';

export type ExportFormat = 'stl' | 'obj' | '3mf' | 'gcode';

export interface ExportOptions {
  format: ExportFormat;
  binary: boolean;
  includeMetadata: boolean;
  printerProfile?: PrinterProfile;
}

export interface PrinterProfile {
  name: string;
  bedSize: { x: number; y: number; z: number };
  nozzleDiameter: number;
  filamentDiameter: number;
  printSpeed: number;
  travelSpeed: number;
  retraction: { distance: number; speed: number };
  temperature: { nozzle: number; bed: number };
  layerHeight: number;
}

/**
 * Export to OBJ format
 */
export function exportToOBJ(object: Mesh | Group, filename: string): void {
  const exporter = new OBJExporter();
  const result = exporter.parse(object);

  downloadFile(result, filename, 'text/plain');
}

/**
 * Export to 3MF format (simplified XML-based format)
 */
export function exportTo3MF(object: Mesh | Group, filename: string, params: CookieCutterParams): void {
  const vertices: number[] = [];
  const triangles: number[][] = [];
  let vertexOffset = 0;

  // Collect all vertices and triangles
  object.traverse((child) => {
    if (child instanceof THREE.Mesh && child.geometry) {
      const geometry = child.geometry;
      const positionAttribute = geometry.getAttribute('position');

      if (!positionAttribute) return;

      const worldMatrix = child.matrixWorld;

      // Get vertices
      for (let i = 0; i < positionAttribute.count; i++) {
        const vertex = new THREE.Vector3(
          positionAttribute.getX(i),
          positionAttribute.getY(i),
          positionAttribute.getZ(i)
        );
        vertex.applyMatrix4(worldMatrix);
        vertices.push(vertex.x, vertex.y, vertex.z);
      }

      // Get triangles
      const index = geometry.index;
      if (index) {
        for (let i = 0; i < index.count; i += 3) {
          triangles.push([
            index.getX(i) + vertexOffset,
            index.getX(i + 1) + vertexOffset,
            index.getX(i + 2) + vertexOffset
          ]);
        }
      } else {
        for (let i = 0; i < positionAttribute.count; i += 3) {
          triangles.push([
            i + vertexOffset,
            i + 1 + vertexOffset,
            i + 2 + vertexOffset
          ]);
        }
      }

      vertexOffset += positionAttribute.count;
    }
  });

  // Generate 3MF XML
  const xml = generate3MFContent(vertices, triangles, params);

  downloadFile(xml, filename, 'application/vnd.ms-package.3dmanufacturing-3dmodel+xml');
}

/**
 * Generate 3MF XML content
 */
function generate3MFContent(
  vertices: number[],
  triangles: number[][],
  params: CookieCutterParams
): string {
  let vertexData = '';
  for (let i = 0; i < vertices.length; i += 3) {
    vertexData += `    <vertex x="${vertices[i].toFixed(3)}" y="${vertices[i + 1].toFixed(3)}" z="${vertices[i + 2].toFixed(3)}" />\n`;
  }

  let triangleData = '';
  for (const triangle of triangles) {
    triangleData += `    <triangle v1="${triangle[0]}" v2="${triangle[1]}" v3="${triangle[2]}" />\n`;
  }

  return `<?xml version="1.0" encoding="UTF-8"?>
<model unit="millimeter" xml:lang="en-US" xmlns="http://schemas.microsoft.com/3dmanufacturing/core/2015/02">
  <metadata name="Title">Cookie Cutter</metadata>
  <metadata name="Designer">Claude Code - Cookie Cutter Designer</metadata>
  <metadata name="Description">Custom 3D-printable cookie cutter</metadata>
  <metadata name="WallThickness">${params.wallThickness}</metadata>
  <metadata name="CuttingHeight">${params.cuttingHeight}</metadata>
  <resources>
    <object id="1" type="model">
      <mesh>
        <vertices>
${vertexData}
        </vertices>
        <triangles>
${triangleData}
        </triangles>
      </mesh>
    </object>
  </resources>
  <build>
    <item objectid="1" />
  </build>
</model>`;
}

/**
 * Generate GCODE for direct printing
 */
export function exportToGCODE(
  object: Mesh | Group,
  filename: string,
  profile: PrinterProfile,
  params: CookieCutterParams
): void {
  const gcode = generateGCODE(object, profile, params);
  downloadFile(gcode, filename, 'text/plain');
}

/**
 * Generate GCODE content
 */
function generateGCODE(
  object: Mesh | Group,
  profile: PrinterProfile,
  params: CookieCutterParams
): string {
  const lines: string[] = [];

  // Header
  lines.push('; GCODE generated by Cookie Cutter Designer');
  lines.push('; https://claude.com/claude-code');
  lines.push(`; Printer Profile: ${profile.name}`);
  lines.push(`; Date: ${new Date().toISOString()}`);
  lines.push('');

  // Start GCODE
  lines.push('; Start GCODE');
  lines.push('G21 ; Set units to millimeters');
  lines.push('G90 ; Use absolute positioning');
  lines.push('M82 ; Use absolute distances for extrusion');
  lines.push(`M104 S${profile.temperature.nozzle} ; Set nozzle temperature`);
  lines.push(`M140 S${profile.temperature.bed} ; Set bed temperature`);
  lines.push('M190 S' + profile.temperature.bed + ' ; Wait for bed temperature');
  lines.push('M109 S' + profile.temperature.nozzle + ' ; Wait for nozzle temperature');
  lines.push('G28 ; Home all axes');
  lines.push('G1 Z15.0 F6000 ; Move the platform down 15mm');
  lines.push('G92 E0 ; Reset extruder');
  lines.push('G1 F200 E3 ; Extrude 3mm of filament');
  lines.push('G92 E0 ; Reset extruder');
  lines.push('');

  // Calculate center position
  const box = new THREE.Box3().setFromObject(object);
  const size = box.getSize(new THREE.Vector3());
  const center = box.getCenter(new THREE.Vector3());

  const startX = (profile.bedSize.x - size.x) / 2;
  const startY = (profile.bedSize.y - size.y) / 2;

  lines.push('; Print moves');
  lines.push(`; Object size: ${size.x.toFixed(2)} x ${size.y.toFixed(2)} x ${size.z.toFixed(2)} mm`);
  lines.push(`; Estimated layers: ${Math.ceil(size.y / profile.layerHeight)}`);
  lines.push('');

  // Simple path generation (perimeter only for now)
  const layerCount = Math.ceil(size.y / profile.layerHeight);
  let e = 0; // Extrusion amount

  for (let layer = 0; layer < layerCount; layer++) {
    const z = layer * profile.layerHeight;
    lines.push(`; Layer ${layer + 1}/${layerCount}`);
    lines.push(`G0 Z${z.toFixed(3)} F${profile.travelSpeed}`);

    // Simple square perimeter (placeholder - real slicing would be more complex)
    const points = [
      [startX, startY + z],
      [startX + size.x, startY + z],
      [startX + size.x, startY + size.z + z],
      [startX, startY + size.z + z],
      [startX, startY + z]
    ];

    for (let i = 0; i < points.length; i++) {
      const [x, y] = points[i];
      if (i === 0) {
        lines.push(`G0 X${x.toFixed(3)} Y${y.toFixed(3)} F${profile.travelSpeed} ; Move to start`);
      } else {
        const distance = Math.sqrt(
          Math.pow(points[i][0] - points[i - 1][0], 2) +
          Math.pow(points[i][1] - points[i - 1][1], 2)
        );
        e += (distance * profile.layerHeight * profile.nozzleDiameter) /
          (Math.PI * Math.pow(profile.filamentDiameter / 2, 2));
        lines.push(`G1 X${x.toFixed(3)} Y${y.toFixed(3)} E${e.toFixed(5)} F${profile.printSpeed}`);
      }
    }
    lines.push('');
  }

  // End GCODE
  lines.push('; End GCODE');
  lines.push('M104 S0 ; Turn off nozzle');
  lines.push('M140 S0 ; Turn off bed');
  lines.push('G91 ; Relative positioning');
  lines.push('G1 E-2 F300 ; Retract filament');
  lines.push('G1 Z10 F3000 ; Move Z up');
  lines.push('G90 ; Absolute positioning');
  lines.push('G28 X0 Y0 ; Home X and Y');
  lines.push('M84 ; Disable steppers');
  lines.push('; Total extrusion: ' + e.toFixed(2) + 'mm');

  return lines.join('\n');
}

/**
 * Download file helper
 */
function downloadFile(content: string, filename: string, mimeType: string): void {
  const blob = new Blob([content], { type: mimeType });
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = filename;
  link.click();
  URL.revokeObjectURL(url);
}

/**
 * Get default printer profiles
 */
export function getDefaultPrinterProfiles(): PrinterProfile[] {
  return [
    {
      name: 'Prusa i3 MK3S',
      bedSize: { x: 250, y: 210, z: 210 },
      nozzleDiameter: 0.4,
      filamentDiameter: 1.75,
      printSpeed: 3000,
      travelSpeed: 7200,
      retraction: { distance: 0.8, speed: 2400 },
      temperature: { nozzle: 215, bed: 60 },
      layerHeight: 0.2
    },
    {
      name: 'Creality Ender 3',
      bedSize: { x: 220, y: 220, z: 250 },
      nozzleDiameter: 0.4,
      filamentDiameter: 1.75,
      printSpeed: 3000,
      travelSpeed: 6000,
      retraction: { distance: 5, speed: 2700 },
      temperature: { nozzle: 200, bed: 60 },
      layerHeight: 0.2
    },
    {
      name: 'Bambu Lab X1',
      bedSize: { x: 256, y: 256, z: 256 },
      nozzleDiameter: 0.4,
      filamentDiameter: 1.75,
      printSpeed: 12000,
      travelSpeed: 30000,
      retraction: { distance: 0.8, speed: 4200 },
      temperature: { nozzle: 220, bed: 65 },
      layerHeight: 0.2
    }
  ];
}

/**
 * Estimate file sizes for different formats
 */
export function estimateExportSize(object: Mesh | Group, format: ExportFormat): number {
  let triangleCount = 0;

  object.traverse((child) => {
    if (child instanceof THREE.Mesh && child.geometry) {
      const geometry = child.geometry;
      if (geometry.index) {
        triangleCount += geometry.index.count / 3;
      } else if (geometry.attributes.position) {
        triangleCount += geometry.attributes.position.count / 3;
      }
    }
  });

  switch (format) {
    case 'stl':
      return 84 + triangleCount * 50; // Binary STL
    case 'obj':
      return triangleCount * 150; // Approximate text size
    case '3mf':
      return 1000 + triangleCount * 100; // XML overhead + triangle data
    case 'gcode':
      return triangleCount * 80; // Approximate GCODE size
    default:
      return 0;
  }
}
